// Importa o m√≥dulo 'readFileSync' e 'writeFileSync' do Node.js para leitura de arquivos
import { readFileSync, writeFileSync } from "fs"

// Importa o m√≥dulo 'chalk' para estiliza√ß√£o de texto no console
import chalk from "chalk"

// Importa o m√≥dulo 'tz' para segmenta√ß√£o de datas e periodos.
import pkg from 'moment-timezone'
const { tz } = pkg

// Fun√ß√£o que recebe uma string e um separador e retorna a primeira parte da string antes do separador
export const Splitt = (value, where) => where.split(value)[0]

// Fun√ß√£o que recebe um valor em milissegundos e retorna uma Promise que resolve ap√≥s o tempo especificado
export const Delay = (x) => new Promise(resolve => setTimeout(resolve, x))

// Fun√ß√£o que retorna a data atual formatada como "DD/MM/YY" no fuso hor√°rio de S√£o Paulo
export const Date = () => tz("America/Sao_Paulo").format("DD/MM/YY")

// Fun√ß√£o que retorna a hora atual formatada como "HH:mm:ss" no fuso hor√°rio de S√£o Paulo
export const Hour = () => tz("America/Sao_Paulo").format("HH:mm:ss")

// Fun√ß√£o que recebe um objeto com o caminho e nome do arquivo e o conte√∫do a ser salvo em JSON
// e escreve o conte√∫do no arquivo especificado
export const Save = ({file_path, filename}) =>  writeFileSync(file_path, JSON.stringify(filename))

// Fun√ß√£o que recebe um objeto e retorna o valor da primeira chave que n√£o √© 'messageTimestamp', 'pushName' ou 'message'
export const Key = (a) => a[Object.keys(a).find((key) => !['messageTimestamp', 'pushName', 'message'].includes(key))]

// Fun√ß√£o que recebe um objeto com um valor a ser testado e uma express√£o regular e retorna true se o valor corresponde √† express√£o regular
export const Audition = ({ from, where }) => new RegExp(from).test(where)

// Conjunto para armazenar temporariamente valores que foram processados recentemente
const Protect = new Set()

// Fun√ß√£o que recebe um valor e adiciona-o ao conjunto de valores protegidos por um per√≠odo de 8 segundos
export const Spam = (x) => { Protect.add(x); setTimeout(() => Protect.delete(x), 8000) }

// Fun√ß√£o que recebe um valor e verifica se ele est√° atualmente protegido pelo conjunto de valores protegidos
export const isSpam = (x) => !!Protect.has(x)

// Conjunto para armazenar temporariamente valores que est√£o sendo processados
const Await = new Set()

// Fun√ß√£o que recebe um valor e adiciona-o ao conjunto de valores aguardando processamento por um per√≠odo de 4 segundos
export const Cooldown = (x) => { Await.add(x); setTimeout(() => Await.delete(x), 8000) }

// Fun√ß√£o que recebe um valor e remove-o do conjunto de valores aguardando processamento
export const DownColling = (x) => Await.delete(x)

// Fun√ß√£o que recebe um valor e verifica se ele est√° atualmente aguardando processamento pelo conjunto de valores aguardando processamento
export const isColling = (x) => !!Await.has(x)

// Fun√ß√£o que retorna o n√∫mero de valores atualmente aguardando processamento pelo conjunto de valores aguardando processamento
export const sizeCooldown = (x) => Await

// Conjunto para armazenar temporariamente valores que est√£o sendo processados
const Ignore = new Set()

// Fun√ß√£o que recebe um valor e adiciona-o ao conjunto de valores aguardando processamento por um per√≠odo de 4 segundos
export const doIgnore = (x) => { Ignore.add(x); setTimeout(() => Ignore.delete(x), 12000) }

// Fun√ß√£o que recebe um valor e verifica se ele est√° atualmente aguardando processamento pelo conjunto de valores aguardando processamento
export const IsIgnoring = (x) => !!Ignore.has(x)

// Fun√ß√£o respons√°vel por imprimir mensagens no console
export const console_message = ({ message_param, config }) => {

    // Faz a leitura do arquivo de configura√ß√£o
    var Config = JSON.parse(readFileSync("./root/configurations.json"))

    // Extrai a mensagem de texto e o n√∫mero do remetente da mensagem a partir do objeto de configura√ß√£o
    const Text = config?.msg?.key?.parameters?.details[1]?.sender?.messageText ?? ''; if(!Text) return
    const Sender = config?.msg?.key?.parameters?.details[1]?.sender?.messageNumber ?? ''; if(!Sender) return

    // Verifica se a mensagem √© proveniente de um grupo
    const isGroup = config?.msg?.key?.boolean?.isGroup

    // Fun√ß√£o que retorna o nome do grupo a partir do objeto de configura√ß√£o
    const group = ({ metadata, config }) => {
        // Extrai o ID do grupo a partir do objeto de configura√ß√£o
        const groupJid = config?.msg?.key?.parameters?.details[0]?.messageKey?.remoteJid?.split('@')[0]
        // Procura o √≠ndice do grupo no objeto 'metadata'
        const chatIndex = metadata?.remoteJid?.map(chat => Object.keys(chat)[0].split('@')[0])?.indexOf(groupJid)

        // Retorna o nome do grupo
        return metadata.remoteJid[chatIndex][`${groupJid}@g.us`].subject
    }

    // Imprime a mensagem formatada no console
    console.log(
        // Utiliza o m√≥dulo 'chalk' para estilizar o texto com a cor especificada
        chalk.rgb(123, 45, 67).bold(
            // Substitui as vari√°veis no texto da mensagem com seus valores correspondentes
            message_param
            .replace(/@botname/g, `${Config.parameters.bot[0].name} ::: ${Config.parameters.bot[0].username}`)
            .replace(/@user/g, Sender)
            .replace(/@entry/g, chalk.hex('#DEADED').bgGreen.bold(Text))
            .replace(/@hour/g, Hour()) // N√£o foi declarada a fun√ß√£o 'Hour', deve ser definida em outro lugar
            .replace(/@date/g, Date())
            .replace(/@group/g, isGroup? group({ metadata: Config?.parameters?.metadata?.store[0], config: config }) : '')
        )
    );
}

// Esta fun√ß√£o recebe dois par√¢metros: Key e MP.
export const createdData = async (Key, MP) => {

    // L√™ o arquivo de configura√ß√µes.
    var Config = JSON.parse(readFileSync("./root/configurations.json"))

    // Obt√©m o caminho do arquivo onde as configura√ß√µes ser√£o salvas.
    const Path = Config.parameters.commands[1].paths.config_file

    // Obt√©m a lista de grupos armazenados nas configura√ß√µes.
    const { remoteJid } = Config.parameters.metadata.store[0]

    // Cria uma fun√ß√£o que retorna um objeto JSON com as informa√ß√µes do grupo.
    var jsonData = async () => `{"${Key.remoteJid}": ${JSON.stringify(await MP.groupMetadata(Key.remoteJid))}}`

    // Converte a string JSON em um objeto JavaScript.
    var jsonObj = JSON.parse(await jsonData())

    // Adiciona o objeto JSON √† lista de grupos armazenados.
    remoteJid.push(jsonObj)

    // Salva as configura√ß√µes atualizadas no arquivo de configura√ß√µes.
    writeFileSync(Path, JSON.stringify(Config))
}

/**
 * Atualiza o arquivo de configura√ß√£o do bot com as informa√ß√µes de autentica√ß√£o fornecidas.
 * @param {object} MP - Objeto contendo informa√ß√µes de autentica√ß√£o do bot.
 */
export const Named = ({ MP }) => {

    // L√™ o arquivo de configura√ß√µes.
    var Config = JSON.parse(readFileSync("./root/configurations.json"))

    // Obt√©m o caminho do arquivo de configura√ß√£o.
    const Path = Config.parameters.commands[1].paths.config_file

    /**
     * Extrai o ID do bot a partir do ID de autentica√ß√£o.
     *
     * @param {string} id - ID de autentica√ß√£o do bot.
     * @returns {string} - ID do bot.
     */
    function extractBotId(id) {
        const [, N_1ID = ''] = id.match(/(\w+)(@\w+)?/) || []
        const [, N_2ID = ''] = N_1ID.match(/(\w+)(:\w+)?/) || []
        return N_2ID
    }

    /**
     * Atualiza as propriedades de configura√ß√£o do bot com as informa√ß√µes de autentica√ß√£o fornecidas.
     * @param {object} config - Objeto de configura√ß√£o do bot.
     * @param {object} authState - Objeto contendo as informa√ß√µes de autentica√ß√£o do bot.
     * @returns {object} - Objeto de configura√ß√£o atualizado.
     * @throws {Error} - Se as propriedades do bot n√£o forem encontradas no arquivo de configura√ß√£o.
     */
    function updateBotConfig(config, authState) {
        const Config = config.parameters.bot[0]

        if (!Config) {
            throw new Error('N√£o foi poss√≠vel encontrar as propriedades do bot no arquivo de configura√ß√£o.')
        }

        const { id, name } = authState?.creds?.me || {}

        // Extrai o ID do bot e atualiza as propriedades correspondentes no objeto de configura√ß√£o.
        Config.id = extractBotId(id) || '00000000000'
        Config.username = name || 'BOT'
        Config.trusted = 'trusted'

        return config
    }

    // Escreve o objeto de configura√ß√£o atualizado no arquivo.
    writeFileSync(Path, JSON.stringify(updateBotConfig(Config, MP.authState)))
}

// Esta fun√ß√£o recebe dois par√¢metros: MP (o cliente do WhatsApp) e a mensagem que receber√° as rea√ß√µes.
export const TenCount = async ({ MP, message }) => {

    // Cria um array com as rea√ß√µes que ser√£o enviadas.
    const reactions = ['0Ô∏è‚É£','1Ô∏è‚É£','2Ô∏è‚É£','3Ô∏è‚É£','4Ô∏è‚É£','5Ô∏è‚É£','6Ô∏è‚É£','7Ô∏è‚É£','8Ô∏è‚É£','9Ô∏è‚É£','üîü','‚úÖ']

    // Cria uma fun√ß√£o ass√≠ncrona que enviar√° as rea√ß√µes de forma sequencial.
    // A fun√ß√£o √© autoexecut√°vel (IIFE) e inicia com o par√¢metro "x" igual a 0.
    (async function sendReactionLoop(x){

        // Se o par√¢metro "x" for maior ou igual a 12, encerra a execu√ß√£o.
        if (x >= 12) return

        // Chama a fun√ß√£o "sendReaction" para enviar a rea√ß√£o "x" na mensagem recebida.
        await sendReaction({
            client: MP,
            param: message,
            answer: reactions[x]
        })

        // Aguarda 1 segundo antes de chamar a pr√≥xima itera√ß√£o da fun√ß√£o.
        await new Promise(resolve => setTimeout(resolve, 1000))

        // Chama a fun√ß√£o novamente com o par√¢metro "x" incrementado em 1.
        sendReactionLoop( x + 1 )

    })(0)
}

/**
 * Obt√©m informa√ß√µes do grupo, como se o usu√°rio √© um administrador ou se o bot √© um administrador do grupo.
 * @param {string} Type - O tipo de informa√ß√£o a ser obtida. Pode ser "isAdmin" ou "isBotAdmin".
 * @param {object} groupMetadata - Metadados do grupo, contendo informa√ß√µes sobre os participantes.
 * @param {object} message - Objeto da mensagem que disparou a fun√ß√£o.
 * @returns {boolean} - Retorna true se o usu√°rio ou o bot √© um administrador do grupo, dependendo do valor de Type. Retorna false caso contr√°rio.
 */
export const getGroupData = ({ Type, groupMetadata, message }) => {

    // L√™ o arquivo de configura√ß√µes.
    var Config = JSON.parse(readFileSync("./root/configurations.json"))

    // Cria uma fun√ß√£o interna que retorna um array com os JID's dos participantes que s√£o admin ou superadmin.
    const getAdminUsers = participants => 
    participants.filter(user => user.admin === 'admin').map(user => user.id)

    // Extrai o JID remoto e o JID do participante da mensagem.
    const { remoteJid, participant } = message

    // Chama a fun√ß√£o getAdminUsers para obter os JID's dos administradores.
    const adminUsers = getAdminUsers(groupMetadata[remoteJid].participants)

    // Verifica qual √© o valor do par√¢metro Type.
    switch (Type) {

    // Se for "isAdmin", retorna true se o JID do participante estiver na lista de JID's de administradores.
    case 'isAdmin':
        return adminUsers.includes(participant)

    // Se for "isBotAdmin", retorna true se o JID do bot estiver na lista de JID's de administradores.
    case 'isBotAdmin':
        return adminUsers.includes(`${Config.parameters.bot[0].id}@s.whatsapp.net`)

    // Se n√£o for nenhum dos valores acima, retorna false.
    default:
        return false
    }
}

//
/**
 * Fun√ß√£o para gerenciar os comandos "unsafe" dispon√≠veis para uso pelo bot
 * @param {Object} options - um objeto contendo as seguintes propriedades:
 * @param {string} options.Modo - O modo da opera√ß√£o a ser realizada, 'provide' para adicionar um comando unsafe e 'unprovide' para remover um comando unsafe
 * @param {string} options.Parametro - O comando unsafe a ser adicionado ou removido
 * @returns {void} - n√£o retorna nenhum valor, mas altera o arquivo de configura√ß√£o do bot.
 * @throws {Error} Se o modo especificado n√£o for 'provide' ou 'unprovide'.
 * @throws {Error} Se a opera√ß√£o de grava√ß√£o do arquivo de configura√ß√£o falhar.
 */
export const Provided = ({ Modo, Parametro}) =>{

    // L√™ o arquivo de configura√ß√µes do bot
    var Config = JSON.parse(readFileSync("./root/configurations.json"))

    // Obt√©m a lista de comandos unsafe dispon√≠veis a partir das configura√ß√µes do bot
    const provided = Config.parameters.commands[0].execution[1].unsafe

    // Obt√©m o caminho do arquivo de configura√ß√µes do bot a partir das configura√ß√µes do bot
    const path = Config.parameters.commands[1].paths.config_file

    switch(Modo){

    // Adiciona um comando unsafe √† lista de comandos dispon√≠veis
    case 'provide':
        provided.push(Parametro)
        writeFileSync(path, JSON.stringify(Config))
    break

    // Remove um comando unsafe da lista de comandos dispon√≠veis
    case 'unprovide':
        const index = provided.findIndex((el) => el === Parametro)
        if (index !== -1) {
            provided.splice(index, 1);
            writeFileSync(path, JSON.stringify(Config));
        }
    break

    // Se o modo especificado n√£o for 'provide' ou 'unprovide', lan√ßa um erro.
    default:
        throw new Error("Modo inv√°lido especificado.");
    }
}

/**
 * A fun√ß√£o Restricted √© respons√°vel por restringir ou desrestringir um comando para um determinado grupo.
 * @param {Object} options - um objeto contendo as seguintes propriedades:
 * @param {string} options.Modo - a a√ß√£o a ser executada, 'restrict' ou 'unrestrict'.
 * @param {string} options.Parametro - o identificador do grupo a ser restringido ou desrestringido.
 * @returns {void} - n√£o retorna nenhum valor, mas altera o arquivo de configura√ß√£o do bot.
 * @throws {Error} Se o modo especificado n√£o for 'restrict' ou 'unrestrict'.
 * @throws {Error} Se a opera√ß√£o de grava√ß√£o do arquivo de configura√ß√£o falhar.
*/
export const Restricted = ({ Modo, Parametro}) =>{

    // L√™ as configura√ß√µes do bot do arquivo configurations.json
    var Config = JSON.parse(readFileSync("./root/configurations.json"))

    // Acessa o array de grupos restritos e o caminho do arquivo de configura√ß√£o
    const restricted = Config.parameters.commands[0].execution[2].local
    const path = Config.parameters.commands[1].paths.config_file

    // Verifica o modo a ser executado
    switch(Modo){

    // Adiciona o grupo ao array de grupos restritos e escreve as altera√ß√µes no arquivo de configura√ß√£o
    case 'restrict':
        restricted.push(Parametro)
        writeFileSync(path, JSON.stringify(Config))
    break

    // Remove o grupo do array de grupos restritos e escreve as altera√ß√µes no arquivo de configura√ß√£o
    case 'unrestrict':
        const index = restricted.findIndex((el) => el === Parametro)
        if (index !== -1) {
            restricted.splice(index, 1);
            writeFileSync(path, JSON.stringify(Config));
        }
    break
    // Se o modo especificado n√£o for 'restrict' ou 'unrestrict', lan√ßa um erro.
    default:
        throw new Error("Modo inv√°lido especificado.");
    }

}

/**
 * Fun√ß√£o para adicionar ou remover um usu√°rio da lista de propriet√°rios do bot.
 * @param {Object} options - As op√ß√µes para a fun√ß√£o.
 * @param {string} options.Modo - O modo de opera√ß√£o da fun√ß√£o ('addowner' ou 'removeowner').
 * @param {string} options.Parametro - O par√¢metro a ser adicionado ou removido da lista de propriet√°rios.
 * @returns {void} - n√£o retorna nenhum valor, mas altera o arquivo de configura√ß√£o do bot.
 * @throws {Error} Se o modo especificado n√£o for 'addowner' ou 'removeowner'.
 * @throws {Error} Se a opera√ß√£o de grava√ß√£o do arquivo de configura√ß√£o falhar.
 */
export const Owned = ({ Modo, Parametro}) => {
    // L√™ a configura√ß√£o do arquivo de configura√ß√£o.
    var Config = JSON.parse(readFileSync("./root/configurations.json"));

    // Obt√©m a lista de propriet√°rios e o caminho do arquivo de configura√ß√£o.
    const owned = Config.parameters.bot[0].owners;
    const path = Config.parameters.commands[1].paths.config_file;

    switch(Modo){

    // Adiciona um novo propriet√°rio √† lista de propriet√°rios.
    case 'addowner':
        owned.push(Parametro);
        writeFileSync(path, JSON.stringify(Config));
    break;

    // Remove um propriet√°rio existente da lista de propriet√°rios.
    case 'removeowner':
        const index = owned.findIndex((el) => el === Parametro);
        if (index !== -1) {
            owned.splice(index, 1);
            writeFileSync(path, JSON.stringify(Config));
        }
    break;

    // Se o modo especificado n√£o for 'addowner' ou 'removeowner', lan√ßa um erro.
    default:
        throw new Error("Modo inv√°lido especificado.");
    }
}

/**
 * Retorna o texto de uma mensagem, baseado no tipo de mensagem recebida.
 * @param {object} options - As op√ß√µes para obter o texto da mensagem.
 * @param {string} options.MessageType - O tipo de mensagem recebida.
 * @param {object} options.Message - A mensagem recebida.
 * @returns {string} O texto da mensagem recebida.
*/
export const getMessageText = ({ MessageType, Message }) => {
    //Fun√ß√µes para captarem um objeto especifico com base no tipo da mensagem recebida.
    const getConversationText = (MessageType, Message) => { return Message[MessageType] }
    const getExtendedTextMessageText = (MessageType, Message) => { return Message[MessageType]?.text }
    const getImageMessageCaption = (MessageType, Message) => { return Message[MessageType]?.caption ?? Message[MessageType]?.message?.imageMessage?.caption }
    const getVideoMessageCaption = (MessageType, Message) => { return Message[MessageType]?.caption ?? Message[MessageType]?.message?.videoMessage?.caption }
    const getDocumentWithCaptionMessageCaption = (MessageType, Message) => { return Message[MessageType]?.message?.documentMessage?.caption }
    const getListResponseMessageSelectedRowId = (MessageType, Message) => { return Message[MessageType]?.singleSelectReply?.selectedRowId }
    const getButtonsResponseMessageSelectedButtonId = (MessageType, Message) => { return Message[MessageType]?.selectedButtonId }
    const getTemplateButtonReplyMessageSelectedId = (MessageType, Message) => { return Message[MessageType]?.selectedId }
    const getMessageContextInfoSelectedButtonOrRowIdOrText = (MessageType, Message) => { return Message[MessageType]?.selectedButtonId || Message[MessageType]?.singleSelectReply.selectedRowId || Message.text }
    const getDefault = (MessageType) => { return JSON.stringify(MessageType) }

    //M√©todo para definir qual √© o tipo de mensagem.
    switch (MessageType) {
        case 'conversation':
        return getConversationText(MessageType, Message);
        case 'extendedTextMessage':
        return getExtendedTextMessageText(MessageType, Message);
        case 'imageMessage':
        return getImageMessageCaption(MessageType, Message);
        case 'videoMessage':
        return getVideoMessageCaption(MessageType, Message);
        case 'documentWithCaptionMessage':
        return getDocumentWithCaptionMessageCaption(MessageType, Message);
        case 'listResponseMessage':
        return getListResponseMessageSelectedRowId(MessageType, Message);
        case 'buttonsResponseMessage':
        return getButtonsResponseMessageSelectedButtonId(MessageType, Message);
        case 'templateButtonReplyMessage':
        return getTemplateButtonReplyMessageSelectedId(MessageType, Message);
        case 'messageContextInfo':
        return getMessageContextInfoSelectedButtonOrRowIdOrText(MessageType, Message);
        default:
        return getDefault(MessageType);
    }
}

/**
 * Detecta o status da mensagem com base no objeto de mensagem e no tipo de mensagem.
 * @param {object} param - O objeto de par√¢metros contendo a mensagem e o tipo de mensagem.
 * @param {object} param.Message - O objeto de mensagem.
 * @param {string} param.MessageType - O tipo de mensagem.
 * @returns {string} Uma string que indica o status da mensagem detectada.
*/
export const detectMessageStatus = ({ Message, MessageType }) => {
    //Verifica se recebeu uma mensagem do tipo status.
    if (Message?.[MessageType]?.groupId === 'status@broadcast') return 'Publica√ß√£o de status detectada.'

    //Verifica se √© uma mensagem conhecida (N√£o nula).
    const detectedStatus = Message == null || Message[MessageType]?.groupId == null
    ? null
    : 'Mensagem indefinida.' || 'Mensagem desconhecida.'

    return detectedStatus
}